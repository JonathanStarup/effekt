module examples/pos/build

import immutable/list
import immutable/option

effect Need(key: String): Int
effect NeedInput(key: String): Int
effect KeyNotFound[A](key: String): A

def find(store: List[(String,Int)], key: String): Int / KeyNotFound = {
    store match {
        case Nil() => do KeyNotFound(key)
        case Cons((k, v), xs) => if (k == key) { v } else { find(xs, key) }
    }
}

def build(target: String) { tasks: String => Int / { Need } }: Int / {} =
    try { tasks(target) }
    with Need { requestedKey =>
        resume(build(requestedKey) { k => tasks(k) })
    }

// effect transformer "memo"
def memo[R] { prog: R / { Need } } = {
    var store: List[(String,Int)] = Nil();
    try {
        prog()
    } with Need { (key) =>
        try {
            resume(find(store, key))
        } with KeyNotFound { (k) =>
            val v = do Need(k);
            store = Cons((k, v), store);
            resume(v)
        }
    }
}

def supplyInput[R](store: List[(String,Int)]) { prog: R / { NeedInput } } = {
    try { prog() } with NeedInput { (key) => resume(find(store, key)) }
}



// Spreadsheet example from "Build systems ala Carte"
//  |  A | B
// 1| 10 | A1 + A2
// 2| 20 | B1 * 2
def example1(key: String): Int / { Need, NeedInput, Console } = {
    println(key);
    key match {
        case "B1" => do Need("A1") + do Need("A2")
        case "B2" => do Need("B1") * 2
        case _ => do NeedInput(key)
    }
}

// Needing the same key twice
def example2(key: String) = {
    println(key);
    key match {
        case "B1" => do Need("A1") + do Need("A2")
        case "B2" => do Need("B1") * do Need("B1")
        case _ => do NeedInput(key)
    }
}

def main() = {
    val inputs = [("A1", 10), ("A2", 20)];
    try {
        val result1 = supplyInput(inputs) { build ("B2") { (key) => example1(key) } };
        println(result1);
        println("");
        val result2 = supplyInput(inputs) { build ("B2") { (key) => example2(key) } };
        println(result2);
        println("");
        val result3 = supplyInput(inputs) { build ("B2") { (key) => memo { example2(key) } } };
        println(result3)
    } with KeyNotFound { (key) => println("Key not found: " ++ key) }
}
