module immutable/dequeue

import immutable/list
import immutable/option

// An implementation of a functional dequeue, using Okasaki's
// bankers dequeue implementation.
//
// Translation from the Haskell implementation:
//   https://hackage.haskell.org/package/dequeue-0.1.12/docs/src/Data-Dequeue.html#Dequeue
type Dequeue[R]{
  Dequeue(front: List[R], frontSize: Int, rear: List[R], rearSize: Int)
}

def emptyQueue[R](): Dequeue[R] { Dequeue(Nil(), 0, Nil(), 0) }

def isEmpty[R](dq: Dequeue[R]): Boolean {
  dq match {
    case Dequeue(f, fs, r, rs) => (fs == 0) && (rs == 0)
  }
}

def size[R](dq: Dequeue[R]): Int {
  dq match {
    case Dequeue(f, fs, r, rs) => fs + rs
  }
}

def dequeueFirst[R](dq: Dequeue[R]): Option[R] {
  dq match {
    case Dequeue(f, fs, r, rs) =>
      if ((fs == 0) && (rs == 1)) { headOption(r) }
      else { headOption(f) }
  }
}

def dequeueLast[R](dq: Dequeue[R]): Option[R] {
  dq match {
      case Dequeue(f, fs, r, rs) =>
        if ((fs == 1) && (rs == 0)) { headOption(f) }
        else { headOption(r) }
  }
}

def check[R](dq: Dequeue[R]): Dequeue[R] {
  dq match {
    case Dequeue(f, fs, r, rs) =>
      val c = 4;
      val size1 = (fs + rs) / 2;
      val size2 = (fs + rs) - size1;

      if (fs > c * rs + 1) {
          val front = take(f, size1);
          val rear = append(r, reverse(drop(f, size1)));
          Dequeue(front, size1, rear, size2)
      } else if (rs > c * fs + 1) {
          val front = append(f, reverse(drop(r, size1)));
          val rear = take(r, size1);
          Dequeue(front, size2, rear, size1)
      } else {
          return dq
      }
  }
}

def pushFront[R](dq: Dequeue[R], el: R): Dequeue[R] {
  dq match {
    case Dequeue(f, fs, r, rs) => check(Dequeue(Cons(el, f), fs + 1, r, rs))
  }
}

def popFront[R](dq: Dequeue[R]): Option[Tuple2[R, Dequeue[R]]] {
  dq match {
    case Dequeue(Nil(), fs, Cons(x, Nil()), rs) =>
        Some((x, emptyQueue[R]()))
    case Dequeue(Nil(), fs, r, rs) =>
        None[Tuple2[R, Dequeue[R]]]()
    case Dequeue(Cons(x, rest), fs, r, rs) =>
        Some((x, check(Dequeue(rest, fs - 1, r, rs))))
  }
}

def pushBack[R](dq: Dequeue[R], el: R): Dequeue[R] {
  dq match {
    case Dequeue(f, fs, r, rs) => check(Dequeue(f, fs, Cons(el, r), rs + 1))
  }
}

def popBack[R](dq: Dequeue[R]): Option[(R, Dequeue[R])] {
  dq match {
    case Dequeue(Cons(x, Nil()), fs, Nil(), rs) =>
        Some((x, emptyQueue[R]()))
    case Dequeue(f, fs, Nil(), rs) =>
        None[Tuple2[R, Dequeue[R]]]()
    case Dequeue(f, fs, Cons(x, rest), rs) =>
        Some((x, check(Dequeue(f, fs, rest, rs - 1))))
  }
}
